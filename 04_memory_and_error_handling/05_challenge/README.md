# チャレンジ5

次のコードの出力はどのようになりますか。必要に応じて、cppreference.comにある `std::vector` のドキュメントを参照してください。

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers;

    std::cout << "Initial size: " << numbers.size() << ", capacity: " << numbers.capacity() << std::endl;

    numbers.push_back(1);
    numbers.push_back(2);
    numbers.push_back(3);
    std::cout << "After adding elements: size: " << numbers.size() << ", capacity: " << numbers.capacity() << std::endl;

    numbers.reserve(10);
    std::cout << "After reserving space: size: " << numbers.size() << ", capacity: " << numbers.capacity() << std::endl;
}
```

## 回答
### 事前予想
```bash
Initial size: 0, capacity: 4
After adding elements: size:  3, capacity: 12
After reserving space: size:  3, capacity: 40
```
上記の理由としては、`vector`に何も入っていないとき、サイズは0であるが、予約しているメモリの量はintの最小の数4が入っていると考えた。３つ数字を入れたので`4*3`で12。
最後はint 10個分のメモリの範囲をreserveしたので`4*10`で40と考えた。


### 実行結果
```bash
koki-ota@XH22100101-L:~/ws/src/cpp-01-ja/04_memory_and_error_handling/05_challenge$ ./main
Initial size: 0, capacity: 0
After adding elements: size: 3, capacity: 4
After reserving space: size: 3, capacity: 10
```
`capacity()`の概要が`メモリを再確保せずに格納できる最大の要素数を取得する`であり、メモリの割当数ではなく要素数であったので、はじめの状態と最後の状態については納得した。
しかし、３つの数字を加えたときに`capacity`が4担っている理由が腑に落ちない。Wovey (ChatGPT)によると以下のとおりである。
``````
提供されたコードでは、ベクトル `numbers` が最初に空で初期化されます。その後、`push_back()` 関数を使用して `1`、`2`、`3` の3つの要素がベクトルに追加されます。

`size()` 関数は、ベクトル内の要素の数を返します。この場合、要素の数は `3` です。一方、`capacity()` 関数は、ベクトルの内部ストレージのサイズを返します。このサイズはベクトル内の要素の数と一致するかどうかは保証されていません。

この場合、`capacity()` 関数は `4` を返します。

これは、C++のベクトルは個別ではなく、チャンクごとにメモリを割り当てるためです。要素がベクトルに追加されると、ベクトルは割り当てられたメモリチャンクに十分なスペースがあるかどうかを確認します。十分なスペースがある場合、要素は直接追加されます。しかし、十分なスペースがない場合、ベクトルは新しいメモリチャンクを割り当て、すべての要素を新しいチャンクに移動します。このプロセスを「再割り当て」または「リサイズ」と呼びます。

この特定の場合、ベクトルは最初の状態でデフォルトの容量 `0` を持っています。最初の要素が追加されると、ベクトルは容量 `1` のメモリチャンクを割り当てます。2番目の要素が追加されると、ベクトルは現在のメモリチャンクに十分なスペースがあるかどうかをチェックします。十分なスペースがあるため、要素は再割り当てせずに直接追加されます。同様のプロセスが3番目の要素の追加時にも行われます。

しかし、3番目の要素を追加した後、ベクトルの容量は `3` ではなく `4` になります。これは、ベクトルが将来の追加を予測してより大きなメモリチャンクを割り当てることを決定したためです。容量の増加戦略は、C++標準ライブラリの異なる実装によって異なりますが、容量が2倍または他の予め決まった量で増加することが一般的です。

この場合、実装は容量を `4` に増やすことを選択しました。これは、現在の要素数 `3` よりも大きいです。つまり、ベクトルはメモリを再割り当てすることなく、少なくとも1つの要素を追加するための十分なスペースを確保しています。これにより、要素がベクトルに追加される際に必要な再割り当ての回数を減らすことで、パフォーマンスが向上する可能性があります。

まとめると、ベクトルの容量が `4` になっているのは、実装が将来の追加を予測してより大きなメモリチャンクを割り当てたためであり、現在の要素数が `3` であるにもかかわらずです。